
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>iOS开发---黑魔法之blocksKit分析(上) | 香蕉的技术博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Hundred Wang">
    

    
    <meta name="description" content="目录
上篇链接:IOS开发 - 黑魔法之blocksKit分析(上)
下篇链接:IOS开发 - 黑魔法之blocksKit分析(下)
应用篇含演示demo:IOS开发 - 黑魔法之blocksKit应用篇

BlocksKit项目主页:BlocksKit-github主页

1.前言本篇文章只适合对delegate和block进阶使用,不适合对以上两个概念的初学者学习.高能预警：本篇文章非常长，因">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS开发---黑魔法之blocksKit分析(上)">
<meta property="og:url" content="http://www.hundredone.win/2016/06/20/A-IOS黑魔法/IOS开发---黑魔法之blocksKit分析(上)/index.html">
<meta property="og:site_name" content="香蕉的技术博客">
<meta property="og:description" content="目录
上篇链接:IOS开发 - 黑魔法之blocksKit分析(上)
下篇链接:IOS开发 - 黑魔法之blocksKit分析(下)
应用篇含演示demo:IOS开发 - 黑魔法之blocksKit应用篇

BlocksKit项目主页:BlocksKit-github主页

1.前言本篇文章只适合对delegate和block进阶使用,不适合对以上两个概念的初学者学习.高能预警：本篇文章非常长，因">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1730495-755d908f00d77cf8.gif?imageMogr2/auto-orient/strip">
<meta property="og:updated_time" content="2017-01-03T02:02:37.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS开发---黑魔法之blocksKit分析(上)">
<meta name="twitter:description" content="目录
上篇链接:IOS开发 - 黑魔法之blocksKit分析(上)
下篇链接:IOS开发 - 黑魔法之blocksKit分析(下)
应用篇含演示demo:IOS开发 - 黑魔法之blocksKit应用篇

BlocksKit项目主页:BlocksKit-github主页

1.前言本篇文章只适合对delegate和block进阶使用,不适合对以上两个概念的初学者学习.高能预警：本篇文章非常长，因">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/1730495-755d908f00d77cf8.gif?imageMogr2/auto-orient/strip">

    
    <link rel="alternative" href="/atom.xml" title="香蕉的技术博客" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/fauthor32.ico">
    
    
    <link rel="apple-touch-icon" href="/img/author114.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/author114.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="香蕉的技术博客" title="香蕉的技术博客"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="香蕉的技术博客">香蕉的技术博客</a></h1>
				<h2 class="blog-motto">用卑微的视角,为浩瀚的科技大海共享一份绵薄之力</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives">文章归档</a></li>
					
						<li><a href="/tags">标签</a></li>
					
						<li><a href="/categories">分类</a></li>
					
					<li>
 					
						<form class="search" action="http://zhannei.baidu.com/cse/search" target="_blank">
							<label>Search</label>
						<input name="s" type="hidden" value= 244624813535589000 ><input type="text" name="q" size="30" placeholder="搜索"><br>
						</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/06/20/A-IOS黑魔法/IOS开发---黑魔法之blocksKit分析(上)/" title="iOS开发---黑魔法之blocksKit分析(上)" itemprop="url">iOS开发---黑魔法之blocksKit分析(上)</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Hundred Wang" target="_blank" itemprop="author">Hundred Wang</a>
		
  <p class="article-time">
    <time datetime="2016-06-19T22:49:50.000Z" itemprop="datePublished"> 发表于 2016-06-20</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#目录"><span class="toc-number">1.</span> <span class="toc-text">目录</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-前言"><span class="toc-number">2.</span> <span class="toc-text">1.前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#概述"><span class="toc-number">3.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用-Block-封装-KVO"><span class="toc-number">4.</span> <span class="toc-text">使用 Block 封装 KVO</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#提供接口并在-dealloc-时停止-BlockObservation"><span class="toc-number">5.</span> <span class="toc-text">提供接口并在 dealloc 时停止 BlockObservation</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-首先调用-bk-observedClassesHash-类方法获取所有修改过-dealloc-方法的类的集合-classes"><span class="toc-number">5.1.</span> <span class="toc-text">1. 首先调用 bk_observedClassesHash 类方法获取所有修改过 dealloc 方法的类的集合 classes</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-使用-synchronized-classes-保证互斥，避免同时修改-classes-集合的类过多出现意料之外的结果"><span class="toc-number">5.2.</span> <span class="toc-text">2. 使用 @synchronized (classes) 保证互斥，避免同时修改 classes 集合的类过多出现意料之外的结果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-判断即将调剂方法的类-classToSwizzle-是否调剂过-dealloc-方法"><span class="toc-number">5.3.</span> <span class="toc-text">3. 判断即将调剂方法的类 classToSwizzle 是否调剂过 dealloc 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-如果-dealloc-方法没有调剂过，就会通过-sel-registerName-“dealloc”-方法获取选择子，这行代码并不会真正注册dealloc-选择子而是会获取-dealloc-的选择子，具体原因可以看这个方法的实现-sel-registerName"><span class="toc-number">5.4.</span> <span class="toc-text">4. 如果 dealloc 方法没有调剂过，就会通过 sel_registerName(“dealloc”)方法获取选择子，这行代码并不会真正注册dealloc 选择子而是会获取 dealloc 的选择子，具体原因可以看这个方法的实现 sel_registerName</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-在新的-dealloc-中添加移除-Observer-的方法，-再调用原有的-dealloc"><span class="toc-number">5.5.</span> <span class="toc-text">5. 在新的 dealloc 中添加移除 Observer 的方法， 再调用原有的 dealloc</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-调用-class-addMethod-方法为当前类添加选择子为-dealloc-的方法（当然-99-99-的可能不会成功）"><span class="toc-number">5.5.1.</span> <span class="toc-text">1.  调用 class_addMethod 方法为当前类添加选择子为 dealloc 的方法（当然 99.99% 的可能不会成功）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-获取原有的-dealloc-实例方法"><span class="toc-number">5.5.2.</span> <span class="toc-text">2. 获取原有的 dealloc 实例方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-将原有的实现保存到-originalDealloc-中，防止使用-method-setImplementation-重新设置该方法的过程中调用dealloc-导致无方法可用"><span class="toc-number">5.5.3.</span> <span class="toc-text">3.  将原有的实现保存到 originalDealloc 中，防止使用 method_setImplementation 重新设置该方法的过程中调用dealloc 导致无方法可用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-重新设置-dealloc-方法的实现。同样，将实现存储到-originalDealloc-中防止实现改变"><span class="toc-number">5.5.4.</span> <span class="toc-text">4. 重新设置 dealloc 方法的实现。同样，将实现存储到 originalDealloc 中防止实现改变</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#作者信息"><span class="toc-number">6.</span> <span class="toc-text">作者信息</span></a></li></ol>
		
		</div>
		
		<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li>上篇链接:<a href="http://www.jianshu.com/p/1f6669ee0ddb" target="_blank" rel="external">IOS开发 - 黑魔法之blocksKit分析(上)</a></li>
<li>下篇链接:<a href="http://www.jianshu.com/p/59d2e8a77e05" target="_blank" rel="external">IOS开发 - 黑魔法之blocksKit分析(下)</a></li>
<li>应用篇含演示demo:<a href="http://www.jianshu.com/p/e9ff8c62781a" target="_blank" rel="external">IOS开发 - 黑魔法之blocksKit应用篇</a></li>
</ul>
<p>BlocksKit项目主页:<a href="https://github.com/zwaldowski/BlocksKit" target="_blank" rel="external">BlocksKit-github主页</a></p>
<hr>
<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>本篇文章只适合对delegate和block进阶使用,不适合对以上两个概念的初学者学习.<br>高能预警：本篇文章非常长，因为 BlocksKit 的实现还是比较复杂和有意的。这篇文章不是为了剖析 iOS 开发中的 block 的实现以及它是如何组成甚至使用的，如果你想通过这篇文章来了解 block 的实现，它并不能帮到你。</p>
<p>Block 到底是什么？这可能是困扰很多 iOS 初学者的一个问题。如果你在 Google 上搜索类似的问题时，可以查找到几十万条结果，block 在 iOS 开发中有着非常重要的地位，而且它的作用也越来越重要。</p>
<hr>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>这篇文章仅对 BlocksKit v2.2.5 的源代码进行分析，从框架的内部理解下面的功能是如何实现的：</p>
<p>为 NSArray、 NSDictionary 和 NSSet 等集合类型以及对应的可变集合类型 NSMutableArray、NSMutableDictionary 和 NSMutableSet 添加 bk_each: 等方法完成对集合中元素的快速遍历<br>使用 block 对 NSObject 对象 KVO<br>为 UIView 对象添加 bk_whenTapped: 等方法快速添加手势<br>使用 block 替换 UIKit 中的 delegate ，涉及到核心模块 DynamicDelegate。</p>
<p>BlocksKit 框架中包括但不仅限于上述的功能，这篇文章是对 v2.2.5 版本源代码的分析，其它版本的功能不会在本篇文章中具体讨论。</p>
<p>如何提供简洁的遍历方法</p>
<p>BlocksKit 实现的最简单的功能就是为集合类型添加方法遍历集合中的元素。<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[@[@<span class="number">1</span>,@<span class="number">2</span>,@<span class="number">3</span>] bk_each:^(<span class="name">id</span> obj) &#123;</div><div class="line">    NSLog(@<span class="string">"%@"</span>，obj)<span class="comment">;</span></div><div class="line">&#125;]<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p>这段代码非常简单，我们可以使用 enumerateObjectsUsingBlock: 方法替代 bk_each: 方法：<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[@[@<span class="number">1</span>,@<span class="number">2</span>,@<span class="number">3</span>] enumerateObjectsUsingBlock:^(<span class="name">id</span> obj，NSUInteger idx，BOOL *stop) &#123;</div><div class="line">    NSLog(@<span class="string">"%@"</span>，obj)<span class="comment">;</span></div><div class="line">&#125;]<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p>结果<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">2016<span class="selector-tag">-03-05</span> 16<span class="selector-pseudo">:02</span><span class="selector-pseudo">:57.295</span> <span class="selector-tag">Draveness</span><span class="selector-attr">[10725:453402]</span> 1</div><div class="line">2016<span class="selector-tag">-03-05</span> 16<span class="selector-pseudo">:02</span><span class="selector-pseudo">:57.296</span> <span class="selector-tag">Draveness</span><span class="selector-attr">[10725:453402]</span> 2</div><div class="line">2016<span class="selector-tag">-03-05</span> 16<span class="selector-pseudo">:02</span><span class="selector-pseudo">:57.297</span> <span class="selector-tag">Draveness</span><span class="selector-attr">[10725:453402]</span> 3</div></pre></td></tr></table></figure></p>
<p>这部分代码的实现也没什么难度：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)bk_each:(<span class="keyword">void</span> (^)(<span class="keyword">id</span> obj))block</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSParameterAssert</span>(block != <span class="literal">nil</span>);</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span> enumerateObjectsUsingBlock:^(<span class="keyword">id</span> obj，<span class="built_in">NSUInteger</span> idx，<span class="built_in">BOOL</span> *stop) &#123;</div><div class="line">        block(obj);</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它在 block 执行前会判断传进来的 block 是否为空，然后就是调用遍历方法，把数组中的每一个 obj 传给 block。</p>
<p>BlocksKit 在这些集合类中所添加的一些方法在 Ruby、Haskell 等语言中也同样存在。如果你接触过上面的语言，理解这里方法的功能也就更容易了，不过这不是这篇文章关注的主要内容。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// NSArray+BlocksKit.h</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)bk_each:(<span class="keyword">void</span> (^)(<span class="keyword">id</span> obj))block;</div><div class="line">- (<span class="keyword">void</span>)bk_apply:(<span class="keyword">void</span> (^)(<span class="keyword">id</span> obj))block;</div><div class="line">- (<span class="keyword">id</span>)bk_match:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> obj))block;</div><div class="line">- (<span class="built_in">NSArray</span> *)bk_select:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> obj))block;</div><div class="line">- (<span class="built_in">NSArray</span> *)bk_reject:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> obj))block;</div><div class="line">- (<span class="built_in">NSArray</span> *)bk_map:(<span class="keyword">id</span> (^)(<span class="keyword">id</span> obj))block;</div><div class="line">- (<span class="keyword">id</span>)bk_reduce:(<span class="keyword">id</span>)initial withBlock:(<span class="keyword">id</span> (^)(<span class="keyword">id</span> sum，<span class="keyword">id</span> obj))block;</div><div class="line">- (<span class="built_in">NSInteger</span>)bk_reduceInteger:(<span class="built_in">NSInteger</span>)initial withBlock:(<span class="built_in">NSInteger</span>(^)(<span class="built_in">NSInteger</span> result，<span class="keyword">id</span> obj))block;</div><div class="line">- (<span class="built_in">CGFloat</span>)bk_reduceFloat:(<span class="built_in">CGFloat</span>)inital withBlock:(<span class="built_in">CGFloat</span>(^)(<span class="built_in">CGFloat</span> result，<span class="keyword">id</span> obj))block;</div><div class="line">- (<span class="built_in">BOOL</span>)bk_any:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> obj))block;</div><div class="line">- (<span class="built_in">BOOL</span>)bk_none:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> obj))block;</div><div class="line">- (<span class="built_in">BOOL</span>)bk_all:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> obj))block;</div><div class="line">- (<span class="built_in">BOOL</span>)bk_corresponds:(<span class="built_in">NSArray</span> *)list withBlock:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> obj1，<span class="keyword">id</span> obj2))block;</div></pre></td></tr></table></figure></p>
<hr>
<p><strong>NSObject 上的魔法</strong></p>
<p>NSObject 是 iOS 中的『上帝类』。</p>
<p>在 NSObject 上添加的方法几乎会添加到 Cocoa Touch 中的所有类上，关于 NSObject 的讨论和总共分为以下三部分进行：</p>
<p>1.AssociatedObject<br>2.BlockExecution<br>3.BlockObservation</p>
<p>添加 AssociatedObject</p>
<p>经常跟 runtime 打交道的人不可能不知道 AssociatedObject ，当我们想要为一个已经存在的类添加属性时，就需要用到 AssociatedObject 为类添加属性，而 BlocksKit 提供了更简单的方法来实现，不需要新建一个分类。<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">NSObject</span> *test = [[<span class="symbol">NSObject</span> alloc] init];</div><div class="line">[test bk_associateValue:@<span class="string">"Draveness"</span> withKey:@<span class="string">" name"</span>];</div><div class="line"><span class="symbol">NSLog</span>(@<span class="string">"%@"</span>，[test bk_associatedValueForKey:@<span class="string">"name"</span>]);</div></pre></td></tr></table></figure></p>
<p>输出结果:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2016<span class="selector-tag">-03-05</span> 16<span class="selector-pseudo">:02</span><span class="selector-pseudo">:25.761</span> <span class="selector-tag">Draveness</span><span class="selector-attr">[10699:452125]</span> <span class="selector-tag">Draveness</span></div></pre></td></tr></table></figure>
<p>这里我们使用了 <code>bk_associateValue:withKey:</code>和 <code>bk_associatedValueForKey:</code>两个方法设置和获取 name 对应的值Draveness.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)bk_associateValue:(id)<span class="keyword">value</span> withKey:(<span class="keyword">const</span> <span class="keyword">void</span> *)key</div><div class="line">&#123;</div><div class="line">    objc_setAssociatedObject(self，key，<span class="keyword">value</span>，OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的 OBJC_ASSOCIATION_RETAIN_NONATOMIC 表示当前属性为 retain nonatomic 的，还有其它的参数如下：</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Policies related to associative references.</div><div class="line"> * These are options to objc_setAssociatedObject()</div><div class="line"> */</div><div class="line">typedef OBJC_ENUM(uintptr_t，objc_AssociationPolicy) &#123;</div><div class="line">    OBJC_ASSOCIATION_ASSIGN = <span class="number">0</span>，          <span class="comment">/**&lt; Specifies a weak reference to the associated object. */</span></div><div class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class="number">1</span>，<span class="comment">/**&lt; Specifies a strong reference to the associated object.</span></div><div class="line">                                           *   The association is not made atomically. */</div><div class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC = <span class="number">3</span>，  <span class="comment">/**&lt; Specifies that the associated object is copied.</span></div><div class="line">                                           *   The association is not made atomically. */</div><div class="line">    OBJC_ASSOCIATION_RETAIN = <span class="number">01401</span>，      <span class="comment">/**&lt; Specifies a strong reference to the associated object.</span></div><div class="line">                                           *   The association is made atomically. */</div><div class="line">    OBJC_ASSOCIATION_COPY = <span class="number">01403</span>          <span class="comment">/**&lt; Specifies that the associated object is copied.</span></div><div class="line">                                            *   The association is made atomically. */</div><div class="line">    &#125;;</div></pre></td></tr></table></figure>
<p>上面的这个 NS_ENUM 也没什么好说的，需要注意的是这里没有 weak 属性。</p>
<p>BlocksKit 通过另一种方式实现了『弱属性』：</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)bk_weaklyAssociateValue:(__autoreleasing id)value withKey:(const void *)<span class="built_in">key</span></div><div class="line">    &#123;</div><div class="line">        _BKWeakAssociatedObject *<span class="built_in">assoc</span> = objc_getAssociatedObject(self，<span class="built_in">key</span>);</div><div class="line">        <span class="keyword">if</span> (!<span class="built_in">assoc</span>) &#123;</div><div class="line">            <span class="built_in">assoc</span> = [_BKWeakAssociatedObject <span class="built_in">new</span>];</div><div class="line">            [self bk_associateValue:<span class="built_in">assoc</span> withKey:<span class="built_in">key</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">assoc</span>.value = value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里先获取了一个 _BKWeakAssociatedObject 对象 assoc，然后更新这个对象的属性 value。</p>
<p>因为直接使用 AssociatedObject 不能为对象添加弱属性，所以在这里添加了一个对象，然后让这个对象持有一个弱属性：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@interface</span> <span class="attribute">_BKWeakAssociatedObject </span>: NSObject</div><div class="line"></div><div class="line"><span class="variable">@property</span> (nonatomic，weak) id value;</div><div class="line"></div><div class="line"><span class="variable">@end</span></div><div class="line">    </div><div class="line"><span class="variable">@implementation</span> _BKWeakAssociatedObject</div><div class="line"></div><div class="line"><span class="variable">@end</span></div></pre></td></tr></table></figure>
<p>这就是 BlocksKit 实现弱属性的方法，我觉得这个实现的方法还是比较简洁的。</p>
<p>getter 方法的实现也非常类似：</p>
<pre><code>- (id)bk_associatedValueForKey:(const void *)key
{
    id value = objc_getAssociatedObject(self，key);
    if (value &amp;&amp; [value isKindOfClass:[_BKWeakAssociatedObject class]]) {
        return [(_BKWeakAssociatedObject *)value value];
    }
    return value;
}
</code></pre><hr>
<p> <strong>在任意对象上执行 block</strong></p>
<p>通过这个类提供的一些接口，可以在任意对象上快速执行线程安全、异步的 block，而且这些 block 也可以在执行之前取消。</p>
<pre><code>- (id &lt;NSObject，NSCopying&gt;)bk_performOnQueue:(dispatch_queue_t)queue afterDelay:(NSTimeInterval)delay usingBlock:(void (^)(id obj))block
{
    NSParameterAssert(block != nil);

    return BKDispatchCancellableBlock(queue，delay，^{
        block(self);
    });
}
</code></pre><p>判断 block 是否为空在这里都是细枝末节，这个方法中最关键的也就是它返回了一个可以取消的 block，而这个 block 就是用静态函数 BKDispatchCancellableBlock 生成的。</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">static id &lt;NSObject，NSCopying&gt; <span class="keyword">BKDispatchCancellableBlock(dispatch_queue_t </span>queue，NSTimeInterval delay，void(^<span class="keyword">block)(void)) </span>&#123;</div><div class="line">        <span class="keyword">dispatch_time_t </span>time = <span class="keyword">BKTimeDelay(delay);</span></div><div class="line">        </div><div class="line"><span class="comment">#if DISPATCH_CANCELLATION_SUPPORTED</span></div><div class="line">        if (<span class="keyword">BKSupportsDispatchCancellation()) </span>&#123;</div><div class="line">            <span class="keyword">dispatch_block_t </span>ret = <span class="keyword">dispatch_block_create(0，block);</span></div><div class="line">            <span class="keyword">dispatch_after(time，queue，ret);</span></div><div class="line">            return ret<span class="comment">;</span></div><div class="line">        &#125;</div><div class="line"><span class="comment">#endif</span></div><div class="line">        </div><div class="line">        __block <span class="keyword">BOOL </span>cancelled = NO<span class="comment">;</span></div><div class="line">        void (^wrapper)(<span class="keyword">BOOL) </span>= ^(<span class="keyword">BOOL </span>cancel) &#123;</div><div class="line">            if (cancel) &#123;</div><div class="line">                cancelled = YES<span class="comment">;</span></div><div class="line">                return<span class="comment">;</span></div><div class="line">            &#125;</div><div class="line">            if (!cancelled) <span class="keyword">block();</span></div><div class="line">        &#125;<span class="comment">;</span></div><div class="line">        </div><div class="line">        <span class="keyword">dispatch_after(time，queue，^&#123;</span></div><div class="line">            wrapper(NO)<span class="comment">;</span></div><div class="line">        &#125;)<span class="comment">;</span></div><div class="line">        </div><div class="line">        return wrapper<span class="comment">;</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个函数首先会执行 BKSupportsDispatchCancellation 来判断当前平台和版本是否支持使用 GCD 取消 block，当然一般都是支持的：</p>
<ul>
<li>函数返回的是 YES，那么在 block 被派发到指定队列之后就会返回这个 dispatch_block_t 类型的 block</li>
<li>函数返回的是 NO，那么就会就会手动包装一个可以取消的 block，具体实现的部分如下：</li>
</ul>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">    __block <span class="keyword">BOOL </span>cancelled = NO<span class="comment">;</span></div><div class="line">    void (^wrapper)(<span class="keyword">BOOL) </span>= ^(<span class="keyword">BOOL </span>cancel) &#123;</div><div class="line">        if (cancel) &#123;</div><div class="line">            cancelled = YES<span class="comment">;</span></div><div class="line">            return<span class="comment">;</span></div><div class="line">        &#125;</div><div class="line">        if (!cancelled) <span class="keyword">block();</span></div><div class="line">    &#125;<span class="comment">;</span></div><div class="line">    </div><div class="line">    <span class="keyword">dispatch_after(time，queue，^&#123;</span></div><div class="line">        wrapper(NO)<span class="comment">;</span></div><div class="line">    &#125;)<span class="comment">;</span></div><div class="line">    </div><div class="line">    return wrapper<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>上面这部分代码就先创建一个 wrapper block，然后派发到指定队列，派发到指定队列的这个 block 是一定会执行的，但是怎么取消这个 block 呢？</p>
<p>如果当前 block 没有执行，我们在外面调用一次 wrapper(YES) 时，block 内部的 cancelled 变量就会被设置为 YES，所以 block 就不会执行。</p>
<p>1.dispatch_after — cancelled = NO<br>2.wrapper(YES) — cancelled = YES<br>3.wrapper(NO) — cancelled = YES block 不会执行</p>
<p>这是实现取消的关键部分：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">void</span>)bk_cancelBlock:(<span class="keyword">id</span> &lt;<span class="built_in">NSObject</span>，<span class="built_in">NSCopying</span>&gt;)block</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">NSParameterAssert</span>(block != <span class="literal">nil</span>);</div><div class="line">        </div><div class="line"><span class="meta">#if DISPATCH_CANCELLATION_SUPPORTED</span></div><div class="line">        <span class="keyword">if</span> (BKSupportsDispatchCancellation()) &#123;</div><div class="line">            dispatch_block_cancel((dispatch_block_t)block);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"><span class="meta">#endif</span></div><div class="line">        </div><div class="line">        <span class="keyword">void</span> (^wrapper)(<span class="built_in">BOOL</span>) = (<span class="keyword">void</span>(^)(<span class="built_in">BOOL</span>))block;</div><div class="line">        wrapper(<span class="literal">YES</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>GCD 支持取消 block，那么直接调用 dispatch_block_cancel 函数取消 block<br>GCD 不支持取消 block 那么调用一次 wrapper(YES)</p>
<hr>
<h1 id="使用-Block-封装-KVO"><a href="#使用-Block-封装-KVO" class="headerlink" title="使用 Block 封装 KVO"></a><strong>使用 Block 封装 KVO</strong></h1><p>BlocksKit 对 KVO 的封装由两部分组成：</p>
<ol>
<li>NSObject 的分类负责提供便利方法</li>
<li>私有类 _BKObserver 具体实现原生的 KVO 功能</li>
</ol>
<hr>
<h1 id="提供接口并在-dealloc-时停止-BlockObservation"><a href="#提供接口并在-dealloc-时停止-BlockObservation" class="headerlink" title="提供接口并在 dealloc 时停止 BlockObservation"></a><strong>提供接口并在 dealloc 时停止 BlockObservation</strong></h1><p>NSObject+BKBlockObservation 这个分类中的大部分接口都会调用这个方法:<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">    - (void)<span class="keyword">bk_addObserverForKeyPaths:(NSArray </span>*)keyPaths identifier:(NSString *)identifier options:(NSKeyValueObservingOptions)options <span class="built_in">context</span>:(<span class="keyword">BKObserverContext)context </span>task:(id)task</div><div class="line">    &#123;</div><div class="line"><span class="comment">#1: 检查参数，省略</span></div><div class="line">        </div><div class="line"><span class="comment">#2: 使用神奇的方法在分类中覆写 dealloc</span></div><div class="line">        </div><div class="line">        NSMutableDictionary *<span class="keyword">dict;</span></div><div class="line">        _BKObserver *observer = [[_BKObserver alloc] initWithObservee:self keyPaths:keyPaths <span class="built_in">context</span>:<span class="built_in">context</span> task:task]<span class="comment">;</span></div><div class="line">        [observer startObservingWithOptions:options]<span class="comment">;</span></div><div class="line">        </div><div class="line"><span class="comment">#3: 惰性初始化 bk_observerBlocks 也就是下面的 dict，省略</span></div><div class="line">        </div><div class="line">        <span class="keyword">dict[identifier] </span>= observer<span class="comment">;</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>我们不会在这里讨论 #1、#3 部分，再详细阅读 #2 部分代码之前，先来看一下这个省略了绝大部分细节的核心方法。</p>
<p>使用传入方法的参数创建了一个 _BKObserver 对象，然后调用 <code>startObservingWithOptions:</code>方法开始 KVO 观测相应的属性，然后以 <code>{identifier，obeserver}</code> 的形式存到字典中保存。</p>
<p>这里实在没什么新意，我们在下一小节中会介绍 startObservingWithOptions: 这一方法。</p>
<p>在分类中调剂 dealloc 方法</p>
<p>这个问题我觉得是非常值得讨论的一个问题，也是我最近在写框架时遇到很棘手的一个问题。</p>
<p>当我们在分类中注册一些通知或者使用 KVO 时，很有可能会找不到注销这些通知的时机。</p>
<p>因为在分类中是无法直接实现 dealloc 方法的。 在 iOS8 以及之前的版本，如果某个对象被释放了，但是刚对象的注册的通知没有被移除，那么当事件再次发生，就会向已经释放的对象发出通知，整个程序就会崩溃。</p>
<p>这里解决的办法就十分的巧妙:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">    Class classToSwizzle = <span class="keyword">self</span>.class;</div><div class="line">    <span class="comment">// 获取所有修改过 dealloc 方法的类</span></div><div class="line">    <span class="built_in">NSMutableSet</span> *classes = <span class="keyword">self</span>.class.bk_observedClassesHash;</div><div class="line">    </div><div class="line">    <span class="comment">// 保证互斥避免 classes 出现难以预测的结果</span></div><div class="line">    <span class="keyword">@synchronized</span> (classes) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">// 获取当前类名，并判断是否修改过 dealloc 方法以减少这部分代码的调用次数</span></div><div class="line">        <span class="built_in">NSString</span> *className = <span class="built_in">NSStringFromClass</span>(classToSwizzle);</div><div class="line">        <span class="keyword">if</span> (![classes containsObject:className]) &#123;</div><div class="line">            <span class="comment">// 这里的 sel_registerName 方法会返回 dealloc 的 selector，因为 dealloc 已经注册过</span></div><div class="line">            SEL deallocSelector = sel_registerName(<span class="string">"dealloc"</span>);</div><div class="line">            </div><div class="line">            __block <span class="keyword">void</span> (*originalDealloc)(__<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span>，SEL) = <span class="literal">NULL</span>;</div><div class="line">            </div><div class="line">            <span class="comment">// 实现新的 dealloc 方法</span></div><div class="line">            <span class="keyword">id</span> newDealloc = ^(__<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> objSelf) &#123;</div><div class="line">                <span class="comment">//在方法 dealloc 之前移除所有 observer</span></div><div class="line">                [objSelf bk_removeAllBlockObservers];</div><div class="line">                </div><div class="line">                <span class="keyword">if</span> (originalDealloc == <span class="literal">NULL</span>) &#123;</div><div class="line">                    <span class="comment">// 如果原有的 dealloc 方法没有被找到就会查找父类的 dealloc 方法，调用父类的 dealloc 方法</span></div><div class="line">                    <span class="keyword">struct</span> objc_super superInfo = &#123;</div><div class="line">                        .receiver = objSelf,</div><div class="line">                        .super_class = class_getSuperclass(classToSwizzle)</div><div class="line">                    &#125;;</div><div class="line">                    </div><div class="line">                    <span class="keyword">void</span> (*msgSend)(<span class="keyword">struct</span> objc_super *，SEL) = (__typeof__(msgSend))objc_msgSendSuper;</div><div class="line">                    msgSend(&amp;superInfo，deallocSelector);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// 如果 dealloc 方法被找到就会直接调用该方法，并传入参数</span></div><div class="line">                    originalDealloc(objSelf，deallocSelector);</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">            </div><div class="line">            <span class="comment">// 构建选择子实现 IMP</span></div><div class="line">            IMP newDeallocIMP = imp_implementationWithBlock(newDealloc);</div><div class="line">            </div><div class="line">            <span class="comment">// 向当前类添加方法，但是多半不会成功，因为类已经有 dealloc 方法</span></div><div class="line">            <span class="keyword">if</span> (!class_addMethod(classToSwizzle，deallocSelector，newDeallocIMP，<span class="string">"v@:"</span>)) &#123;</div><div class="line">                <span class="comment">// 获取原有 dealloc 实例方法</span></div><div class="line">                Method deallocMethod = class_getInstanceMethod(classToSwizzle，deallocSelector);</div><div class="line">                </div><div class="line">                <span class="comment">// 存储 dealloc 方法实现防止在 set 的过程中调用该方法</span></div><div class="line">                originalDealloc = (<span class="keyword">void</span>(*)(__<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span>，SEL))method_getImplementation(deallocMethod);</div><div class="line">                </div><div class="line">                <span class="comment">// 重新设置 dealloc 方法的实现，并存储到 originalDealloc 防止方法实现改变</span></div><div class="line">                originalDealloc = (<span class="keyword">void</span>(*)(__<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span>，SEL))method_setImplementation(deallocMethod，newDeallocIMP);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">// 将当前类名添加到已经改变的类的集合中</span></div><div class="line">            [classes addObject:className];</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这部分代码的执行顺序如下:</p>
<h2 id="1-首先调用-bk-observedClassesHash-类方法获取所有修改过-dealloc-方法的类的集合-classes"><a href="#1-首先调用-bk-observedClassesHash-类方法获取所有修改过-dealloc-方法的类的集合-classes" class="headerlink" title="1. 首先调用 bk_observedClassesHash 类方法获取所有修改过 dealloc 方法的类的集合 classes"></a>1. 首先调用 bk_observedClassesHash 类方法获取所有修改过 dealloc 方法的类的集合 classes</h2><h2 id="2-使用-synchronized-classes-保证互斥，避免同时修改-classes-集合的类过多出现意料之外的结果"><a href="#2-使用-synchronized-classes-保证互斥，避免同时修改-classes-集合的类过多出现意料之外的结果" class="headerlink" title="2. 使用 @synchronized (classes) 保证互斥，避免同时修改 classes 集合的类过多出现意料之外的结果"></a>2. 使用 @synchronized (classes) 保证互斥，避免同时修改 classes 集合的类过多出现意料之外的结果</h2><h2 id="3-判断即将调剂方法的类-classToSwizzle-是否调剂过-dealloc-方法"><a href="#3-判断即将调剂方法的类-classToSwizzle-是否调剂过-dealloc-方法" class="headerlink" title="3. 判断即将调剂方法的类 classToSwizzle 是否调剂过 dealloc 方法"></a>3. 判断即将调剂方法的类 classToSwizzle 是否调剂过 dealloc 方法</h2><h2 id="4-如果-dealloc-方法没有调剂过，就会通过-sel-registerName-“dealloc”-方法获取选择子，这行代码并不会真正注册dealloc-选择子而是会获取-dealloc-的选择子，具体原因可以看这个方法的实现-sel-registerName"><a href="#4-如果-dealloc-方法没有调剂过，就会通过-sel-registerName-“dealloc”-方法获取选择子，这行代码并不会真正注册dealloc-选择子而是会获取-dealloc-的选择子，具体原因可以看这个方法的实现-sel-registerName" class="headerlink" title="4. 如果 dealloc 方法没有调剂过，就会通过 sel_registerName(“dealloc”)方法获取选择子，这行代码并不会真正注册dealloc 选择子而是会获取 dealloc 的选择子，具体原因可以看这个方法的实现 sel_registerName"></a>4. 如果 dealloc 方法没有调剂过，就会通过 <code>sel_registerName(“dealloc”)</code>方法获取选择子，这行代码并不会真正注册dealloc 选择子而是会获取 dealloc 的选择子，具体原因可以看这个方法的实现 <code>sel_registerName</code></h2><h2 id="5-在新的-dealloc-中添加移除-Observer-的方法，-再调用原有的-dealloc"><a href="#5-在新的-dealloc-中添加移除-Observer-的方法，-再调用原有的-dealloc" class="headerlink" title="5. 在新的 dealloc 中添加移除 Observer 的方法， 再调用原有的 dealloc"></a>5. 在新的 dealloc 中添加移除 Observer 的方法， 再调用原有的 dealloc</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">    id newDealloc = ^(__unsafe_unretained id objSelf) &#123;</div><div class="line">        [objSelf <span class="keyword">bk_removeAllBlockObservers];</span></div><div class="line">        </div><div class="line">        if (<span class="keyword">originalDealloc </span>== NULL) &#123;</div><div class="line">            struct objc_super superInfo = &#123;</div><div class="line">                .receiver = objSelf,</div><div class="line">                .super_class = class_getSuperclass(classToSwizzle)</div><div class="line">            &#125;<span class="comment">;</span></div><div class="line">            void (*msgSend)(struct objc_super *，SEL) = (__typeof__(msgSend))objc_msgSendSuper<span class="comment">;</span></div><div class="line">            msgSend(&amp;superInfo，deallocSelector)<span class="comment">;</span></div><div class="line">        &#125; else &#123;</div><div class="line">            <span class="keyword">originalDealloc(objSelf，deallocSelector);</span></div><div class="line">        &#125;</div><div class="line">    &#125;<span class="comment">;</span></div><div class="line">    IMP newDeallocIMP = imp_implementationWithBlock(newDealloc)<span class="comment">;</span></div><div class="line">```  </div><div class="line">  *<span class="number">1</span>. 调用 `<span class="keyword">bk_removeAllBlockObservers` </span>方法移除所有观察者，也就是这段代码的最终目的*</div><div class="line">  *<span class="number">2</span>. 根据 <span class="keyword">originalDealloc </span>是否为空，决定是向父类发送消息，还是直接调用 <span class="keyword">originalDealloc </span>并传入 objSelf，deallocSelector 作为参数*</div><div class="line">    </div><div class="line"><span class="comment">## 6.在我们获得了新 dealloc 方法的选择子和 IMP 时，就要改变原有的 dealloc的实现了</span></div></pre></td></tr></table></figure>
<pre><code>if (!class_addMethod(classToSwizzle，deallocSelector，newDeallocIMP，&quot;v@:&quot;)) {
    // The class already contains a method implementation.
    Method deallocMethod = class_getInstanceMethod(classToSwizzle，deallocSelector);

    // We need to store original implementation before setting new implementation
    // in case method is called at the time of setting.
    originalDealloc = (void(*)(__unsafe_unretained id，SEL))method_getImplementation(deallocMethod);

    // We need to store original implementation again，in case it just changed.
    originalDealloc = (void(*)(__unsafe_unretained id，SEL))method_setImplementation(deallocMethod，newDeallocIMP);
}
</code></pre><p>```</p>
<h3 id="1-调用-class-addMethod-方法为当前类添加选择子为-dealloc-的方法（当然-99-99-的可能不会成功）"><a href="#1-调用-class-addMethod-方法为当前类添加选择子为-dealloc-的方法（当然-99-99-的可能不会成功）" class="headerlink" title="1.  调用 class_addMethod 方法为当前类添加选择子为 dealloc 的方法（当然 99.99% 的可能不会成功）"></a>1.  调用 class_addMethod 方法为当前类添加选择子为 dealloc 的方法（当然 99.99% 的可能不会成功）</h3><h3 id="2-获取原有的-dealloc-实例方法"><a href="#2-获取原有的-dealloc-实例方法" class="headerlink" title="2. 获取原有的 dealloc 实例方法"></a>2. 获取原有的 dealloc 实例方法</h3><h3 id="3-将原有的实现保存到-originalDealloc-中，防止使用-method-setImplementation-重新设置该方法的过程中调用dealloc-导致无方法可用"><a href="#3-将原有的实现保存到-originalDealloc-中，防止使用-method-setImplementation-重新设置该方法的过程中调用dealloc-导致无方法可用" class="headerlink" title="3.  将原有的实现保存到 originalDealloc 中，防止使用 method_setImplementation 重新设置该方法的过程中调用dealloc 导致无方法可用"></a>3.  将原有的实现保存到 originalDealloc 中，防止使用 method_setImplementation 重新设置该方法的过程中调用dealloc 导致无方法可用</h3><h3 id="4-重新设置-dealloc-方法的实现。同样，将实现存储到-originalDealloc-中防止实现改变"><a href="#4-重新设置-dealloc-方法的实现。同样，将实现存储到-originalDealloc-中防止实现改变" class="headerlink" title="4. 重新设置 dealloc 方法的实现。同样，将实现存储到 originalDealloc 中防止实现改变"></a>4. 重新设置 dealloc 方法的实现。同样，将实现存储到 originalDealloc 中防止实现改变</h3><p>关于在分类中调剂 dealloc 方法的这部分到这里就结束了，下一节将继续分析私有类 _BKObserver。</p>
<hr>
<h1 id="作者信息"><a href="#作者信息" class="headerlink" title="作者信息"></a>作者信息</h1><p>如果有不足或者错误的地方还望各位读者批评指正，可以评论留言，笔者收到后第一时间回复。</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">具体信息</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">QQ/微信</td>
<td style="text-align:center">hundreda</td>
</tr>
<tr>
<td style="text-align:center">简书号连接</td>
<td style="text-align:center"><a href="http://www.jianshu.com/users/a3ae6d7c68b6/latest_articles" target="_blank" rel="external">iOS-香蕉大大</a></td>
</tr>
<tr>
<td style="text-align:center">GitHub个人开源主页</td>
<td style="text-align:center"><a href="https://github.com/OneHundredSir" target="_blank" rel="external">GitHub连接</a></td>
</tr>
<tr>
<td style="text-align:center">好心人赏我个<code>赞</code></td>
<td style="text-align:center"><code>欢迎各位前来查看，star,感谢各位的阅读</code></td>
</tr>
<tr>
<td style="text-align:center">个人iOS开发QQ讨论群</td>
<td style="text-align:center"><strong>365204530</strong></td>
</tr>
<tr>
<td style="text-align:center"><code>群内规矩</code></td>
<td style="text-align:center"><code>聊天扯淡，讨论技术都行，没有什么群规，不懂就问</code></td>
</tr>
<tr>
<td style="text-align:center">iOS开发类微信订阅号</td>
<td style="text-align:center"><strong>大大家的IOS说</strong></td>
</tr>
<tr>
<td style="text-align:center"><em>微信扫一扫下面二维码</em></td>
<td style="text-align:center"><code>一起用碎片时间学习IOS吧</code></td>
</tr>
</tbody>
</table>
<p><img src="http://upload-images.jianshu.io/upload_images/1730495-755d908f00d77cf8.gif?imageMogr2/auto-orient/strip" alt="微信个人技术订阅号"><br>喜欢的朋友可以赏我2块大洋买糖吃～你的打赏是我前进的动力~一起做一个乐于分享的人吧~</p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS进阶/">iOS进阶</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS黑魔法/">iOS黑魔法</a><a href="/tags/blockKit/">blockKit</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://www.hundredone.win/2016/06/20/A-IOS黑魔法/IOS开发---黑魔法之blocksKit分析(上)/" data-title="iOS开发---黑魔法之blocksKit分析(上) | 香蕉的技术博客" data-tsina="null" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2016/07/05/A-完全小白图文攻略/[IOS开发攻略]---crash-log分析/" title="crash获取">
  <strong>上一篇：</strong><br/>
  <span>
  crash获取</span>
</a>
</div>


<div class="next">
<a href="/2016/06/20/A-IOS黑魔法/[IOS黑魔法]---使用jspatch热更新(介绍篇)/"  title="使用jspatch热更新(介绍篇)">
 <strong>下一篇：</strong><br/> 
 <span>使用jspatch热更新(介绍篇)
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2016/06/20/A-IOS黑魔法/IOS开发---黑魔法之blocksKit分析(上)/" data-title="iOS开发---黑魔法之blocksKit分析(上)" data-url="http://www.hundredone.win/2016/06/20/A-IOS黑魔法/IOS开发---黑魔法之blocksKit分析(上)/"></div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#目录"><span class="toc-number">1.</span> <span class="toc-text">目录</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-前言"><span class="toc-number">2.</span> <span class="toc-text">1.前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#概述"><span class="toc-number">3.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用-Block-封装-KVO"><span class="toc-number">4.</span> <span class="toc-text">使用 Block 封装 KVO</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#提供接口并在-dealloc-时停止-BlockObservation"><span class="toc-number">5.</span> <span class="toc-text">提供接口并在 dealloc 时停止 BlockObservation</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-首先调用-bk-observedClassesHash-类方法获取所有修改过-dealloc-方法的类的集合-classes"><span class="toc-number">5.1.</span> <span class="toc-text">1. 首先调用 bk_observedClassesHash 类方法获取所有修改过 dealloc 方法的类的集合 classes</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-使用-synchronized-classes-保证互斥，避免同时修改-classes-集合的类过多出现意料之外的结果"><span class="toc-number">5.2.</span> <span class="toc-text">2. 使用 @synchronized (classes) 保证互斥，避免同时修改 classes 集合的类过多出现意料之外的结果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-判断即将调剂方法的类-classToSwizzle-是否调剂过-dealloc-方法"><span class="toc-number">5.3.</span> <span class="toc-text">3. 判断即将调剂方法的类 classToSwizzle 是否调剂过 dealloc 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-如果-dealloc-方法没有调剂过，就会通过-sel-registerName-“dealloc”-方法获取选择子，这行代码并不会真正注册dealloc-选择子而是会获取-dealloc-的选择子，具体原因可以看这个方法的实现-sel-registerName"><span class="toc-number">5.4.</span> <span class="toc-text">4. 如果 dealloc 方法没有调剂过，就会通过 sel_registerName(“dealloc”)方法获取选择子，这行代码并不会真正注册dealloc 选择子而是会获取 dealloc 的选择子，具体原因可以看这个方法的实现 sel_registerName</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-在新的-dealloc-中添加移除-Observer-的方法，-再调用原有的-dealloc"><span class="toc-number">5.5.</span> <span class="toc-text">5. 在新的 dealloc 中添加移除 Observer 的方法， 再调用原有的 dealloc</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-调用-class-addMethod-方法为当前类添加选择子为-dealloc-的方法（当然-99-99-的可能不会成功）"><span class="toc-number">5.5.1.</span> <span class="toc-text">1.  调用 class_addMethod 方法为当前类添加选择子为 dealloc 的方法（当然 99.99% 的可能不会成功）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-获取原有的-dealloc-实例方法"><span class="toc-number">5.5.2.</span> <span class="toc-text">2. 获取原有的 dealloc 实例方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-将原有的实现保存到-originalDealloc-中，防止使用-method-setImplementation-重新设置该方法的过程中调用dealloc-导致无方法可用"><span class="toc-number">5.5.3.</span> <span class="toc-text">3.  将原有的实现保存到 originalDealloc 中，防止使用 method_setImplementation 重新设置该方法的过程中调用dealloc 导致无方法可用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-重新设置-dealloc-方法的实现。同样，将实现存储到-originalDealloc-中防止实现改变"><span class="toc-number">5.5.4.</span> <span class="toc-text">4. 重新设置 dealloc 方法的实现。同样，将实现存储到 originalDealloc 中防止实现改变</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#作者信息"><span class="toc-number">6.</span> <span class="toc-text">作者信息</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/Python/" title="Python">Python<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS-Cocos2d-x/" title="iOS Cocos2d-x">iOS Cocos2d-x<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS入门/" title="iOS入门">iOS入门<sup>41</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS进阶/" title="iOS进阶">iOS进阶<sup>17</sup></a></li>
		  
		
		  
			<li><a href="/categories/swift/" title="swift">swift<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/其他/" title="其他">其他<sup>51</sup></a></li>
		  
		
		  
			<li><a href="/categories/源码学习分享/" title="源码学习分享">源码学习分享<sup>2</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/MAC-IOS基础/" title="MAC&amp;&amp;IOS基础">MAC&amp;&amp;IOS基础<sup>14</sup></a></li>
			
		
			
				<li><a href="/tags/iOS黑魔法/" title="iOS黑魔法">iOS黑魔法<sup>11</sup></a></li>
			
		
			
				<li><a href="/tags/算法/" title="算法">算法<sup>10</sup></a></li>
			
		
			
				<li><a href="/tags/面试/" title="面试">面试<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/iOS-Cocos2d-x/" title="iOS Cocos2d-x">iOS Cocos2d-x<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/cocopods/" title="cocopods">cocopods<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Xcode/" title="Xcode">Xcode<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/runtime/" title="runtime">runtime<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/iOS进阶拓展/" title="iOS进阶拓展">iOS进阶拓展<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/HEXO/" title="HEXO">HEXO<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/单元测试/" title="单元测试">单元测试<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/项目仿写/" title="项目仿写">项目仿写<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/blockKit/" title="blockKit">blockKit<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/swift基础/" title="swift基础">swift基础<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/iOS开发/" title="iOS开发">iOS开发<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/控件/" title="控件">控件<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/iOS项目/" title="iOS项目">iOS项目<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Xcode8/" title="Xcode8">Xcode8<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/crash/" title="crash">crash<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/直播/" title="直播">直播<sup>2</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="http://www.jianshu.com/p/ee3c96cee9cd" target="_blank" title="个人介绍">个人介绍</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.jianshu.com/users/a3ae6d7c68b6/latest_articles" target="_blank" title="香蕉简书">香蕉简书</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

  <div >
<!-- /*这一段写的jisuhi在属性部分,微信栏目*/-->
  <!-- /*<p class="asidetitle">微信公众号</p>*/-->
    	<p align=center size:"16" color="red"><strong>常用工具下载网页</strong></p>
	</br>
    <a target="_blank" href="http://xclient.info/">
		  <img src="https://raw.githubusercontent.com/whjool/whjool.github.io/master/img/tool1.png" alt="Ballade" width=100% height=calc(width)/2>
  	</a>
  	</br>
  	<a target="_blank" href="http://www.waitsun.com/">
		  <img src="https://raw.githubusercontent.com/whjool/whjool.github.io/master/img/tool2.png" alt="Ballade" width=100% height=calc(width)/2>
  	</a>

</div>


  <div >
<!-- /*这一段写的jisuhi在属性部分,微信栏目*/-->
<!--   <p class="asidetitle">微信公众号</p>-->
  <p align=center size:"16" color="blue"><strong>微信公众号</strong></p>
  </br>
    <a target="_blank" href="http://www.jianshu.com/p/ee3c96cee9cd">
		  <img src="https://raw.githubusercontent.com/whjool/whjool.github.io/master/img/weixin.jpg" alt="Ballade" width=100% height=calc(width)>
  	</a>
  	<p align=center>欢迎一起利用碎片时间</br>
  		学习iOS技术开发
  	</p>
</div>


  
<div class="github-card">
<p class="asidetitle">Github 名片</p>
<div class="github-card" data-github="OneHundredSir" data-width="220" data-height="119" data-theme="medium">
<script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js" ></script>
</div>
  </div>



</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> 成长之路,厚积薄发 <br/>
			一起成长QQ群:365204530,微信技术公众号:大大家的IOS说</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/6013257513" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		<a href="https://github.com/OneHundredSir" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
		<a href="mailto:15507596877@139.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2017 
		
		<a href="/about" target="_blank" title="Hundred Wang">Hundred Wang</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"hundredone"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>





<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1260805874'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s23.cnzz.com/z_stat.php%3Fid%3D1260805874' type='text/javascript'%3E%3C/script%3E"));</script>

<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
